#!/usr/bin/env python3

"""Build firmware after importing HLS compilation output."""

import argparse
import json
import logging
import os
import pathlib
import re
import shutil
import subprocess
import sys


logger = logging.getLogger('build_fpga')
logger.setLevel(logging.DEBUG)
log_std = logging.StreamHandler(sys.stdout)
logger.addHandler(log_std)

HLS_WRAPPER_FILE = 'nxaccess_sandbox.vhd'
ABORT_IF_REPO_DIRTY = False
HLS_RTL_SYNTH_DIR = '/impl/'
FIRMWARE_SOURCES_DIR = '/rtl/ip_cores/others'
GIT_VALUE_SUBST_REGEX = r'^(\s*w_mm_hls_git\s*<=\s*[xX]\").+(\".*)$'
GENERATE_FW_SCRIPT = './generate_firmware'


def run(command, work_directory):
    """
    Run command and capture output.
    :param command: sequence of program arguments
    :param work_directory: current directory
    :return: list of lines from stdout
    """
    transcript = []
    logger.debug('Running command: {}'.format(' '.join(command)))
    with subprocess.Popen(
            args=command, bufsize=0, stdout=subprocess.PIPE,
            cwd=work_directory, universal_newlines=True) as p:
        for sl in iter(p.stdout.readline, ''):
            transcript.append(sl.rstrip('\n'))
            logger.debug('cmd stdout: {}'.format(sl.rstrip('\n')))
            print(sl, end='')
    return transcript


def which(name, flags=os.X_OK):
    """
    Locates an executable in $PATH
    :param name: executable to locate
    :param flags: expected flag
    :return: list of executables with their paths
    """
    result = []
    paths = os.environ.get('PATH').split(os.pathsep)
    for outerpath in paths:
        for innerpath, _, _ in os.walk(outerpath):
            path = os.path.join(innerpath, name)
            if os.access(path, flags):
                result.append(os.path.normpath(path))
            break
    return result


def get_hls_git_sha1(hls_project_dir):
    """
    Get the git sha1 of the HLS directory.
    :param hls_project_dir: HLS project root directory
    :return: hex string matching the 32-bit MSB of the commit sha1
    """

    # display git version
    git_version_cmd = ['git', '--version']
    git_version = run(command=git_version_cmd, work_directory=hls_project_dir)[0]
    logger.debug('git version: {}'.format(git_version))

    # warn if any committed files are locally modified
    git_rev_parse_cmd = ['git', 'rev-parse', '--show-toplevel']
    git_repo_root = run(command=git_rev_parse_cmd, work_directory=hls_project_dir)[0]
    git_status_cmd = ['git', 'status', '--porcelain']
    changes = run(command=git_status_cmd, work_directory=git_repo_root)
    for change in changes:
        if ABORT_IF_REPO_DIRTY and 'M' in change[:2]:
            raise Exception('Committed file {} has changed, git sha1 will not be relevant.'.format(change[2:]))
        else:
            logger.debug('Non-committed file changed {}'.format(change[2:]))

    # get sha1
    git_rev_cmd = ['git', 'rev-parse', 'HEAD']
    sha1 = run(command=git_rev_cmd, work_directory=hls_project_dir)[0][0:8]
    logger.debug('HLS repo sha1: {}'.format(sha1))
    return sha1


def copy_rtl(hls_project_dir, firmware_project_dir, arguments):
    """
    Copy RTL generated by csynth in an Enyx firmware project.
    :param hls_project_dir: HLS project root directory
    :param firmware_project_dir: Enyx FPGA firmware project directory
    :param dry_run: switch to dry run mode, do not commit changes
    :return: nothing
    """

    # locate RTL directory
    logger.debug('Scanning HLS directory {} for RTL'.format(hls_project_dir))
    hls_project_rtl_dir = None
    for (root, dirs, _) in os.walk(hls_project_dir):
        for dir_ in dirs:
            if HLS_RTL_SYNTH_DIR + arguments.rtl_language in str(pathlib.Path(root) / dir_):
                hls_project_rtl_dir = pathlib.Path(root) / dir_
                break
    logger.debug('Located HLS RTL directory: {}'.format(hls_project_rtl_dir))
    if not hls_project_rtl_dir:
        if arguments.dry_run:
            print('No RTL files found in {}.'.format(hls_project_dir))
        else:
            raise FileNotFoundError(
                'No RTL files found in {}.'.format(hls_project_dir))

    # locate firmware directory
    logger.debug('Scanning firmware directory {} for RTL'.format(
        hls_project_dir))
    firmware_sources_dir = None
    for (root, dirs, files) in os.walk(firmware_project_dir):
        for dir_ in dirs:
            if FIRMWARE_SOURCES_DIR in str(pathlib.Path(root) / dir_):
                firmware_sources_dir = pathlib.Path(root) / dir_
                break
        if firmware_sources_dir:
            break
    logger.debug('Located firmware source directory: {}'.format(
        firmware_sources_dir))

    # copy all RTL files into firmware project
    files_copied = 0
    if hls_project_rtl_dir:
        for (root, dirs, files) in os.walk(str(hls_project_rtl_dir)):
            for file in files:
                rtl_file = pathlib.Path(root) / file
                if arguments.dry_run:
                    logger.debug('Skipping copy for non-file {}'.format(rtl_file))
                else:
                    shutil.copy2(src=str(rtl_file), dst=str(firmware_sources_dir))
                files_copied += 1
    if arguments.dry_run:
        logger.debug('Would have copied {} files'.format(files_copied))
    else:
        logger.debug('Copied {} files'.format(files_copied))


def parse_arguments():
    """Parse arguments from command line interface."""
    parser = argparse.ArgumentParser(description=__doc__)
    pa = parser.add_argument
    # pa('hls-project-directory', type=str, help='HLS project root directory')
    # pa('firmware-project-directory', type=str,
    #    help='Enyx FPGA firmware project directory')
    pa('--dry-run', action='store_true', help='Do not modify output directory')
    pa('--log-file', type=str, help='Log file name')
    pa('--rtl-language', type=str, choices=['verilog','vhdl'], help='rtl language for generated hls files to select')
    arguments = parser.parse_args()
    return arguments


def update_wrapper_git_value(firmware_project_dir, sha1, dry_run):
    """
    Update MM register containing the HLS git sha1.
    :param firmware_project_dir: Enyx FPGA firmware project directory
    :param sha1: HLS sources git commit SHA1
    :param dry_run: switch to dry run mode, do not commit changes
    :return: nothing
    """

    # load wrapper file contents
    logger.debug('Scanning firmware project directory: {}'.format(firmware_project_dir))
    wrapper_file = None
    for (root, dirs, files) in os.walk(firmware_project_dir):
        if HLS_WRAPPER_FILE in files:
            wrapper_file = str(pathlib.Path(root) / HLS_WRAPPER_FILE)
            logger.debug('Located HLS wrapper file: {}'.format(wrapper_file))
            break
    wrapper_source_lines = []
    if wrapper_file:
        wrapper_source_lines = open(wrapper_file).readlines()
        logger.debug('Loaded {} lines from wrapper file'.format(len(wrapper_source_lines), wrapper_file))
    elif not dry_run:
        raise FileNotFoundError('HLS wrapper file {} not found in firmware project.'.format(HLS_WRAPPER_FILE))

    # update git MM register assignation line
    updated_wrapper_source_lines = []
    for line in wrapper_source_lines:
        line = re.sub(GIT_VALUE_SUBST_REGEX, r'\g<1>{}\g<2>'.format(sha1), line)
        updated_wrapper_source_lines.append(line)

    # sanity check
    if (sum(len(line) for line in wrapper_source_lines) !=
            sum(len(lines) for lines in updated_wrapper_source_lines)):
        raise Exception('Error during update process')

    # commit update to wrapper source
    if dry_run:
        logger.debug('Would have updated wrapper file {}'.format(wrapper_file))
    else:
        with open(wrapper_file, 'w') as fh:
            fh.write(''.join(updated_wrapper_source_lines))
        logger.debug('Updated wrapper file {}'.format(wrapper_file))


def build_vivado_project(firmware_project_dir, dry_run):
    """
    Call script for building Vivado firmware project
    :param firmware_project_dir: Enyx FPGA firmware project directory
    :param dry_run: switch to dry run mode, do not commit changes
    :return:
    """

    # locate scripts directory
    firmware_scripts_dir = pathlib.Path('./')
    for (root, dirs, files) in os.walk(firmware_project_dir):
        if 'scripts' in dirs:
            firmware_scripts_dir = pathlib.Path(root) / 'scripts'
    logger.debug('Scripts directory: {}'.format(firmware_scripts_dir))
    generate_firmware_script = firmware_scripts_dir / GENERATE_FW_SCRIPT
    if not dry_run and not os.path.isfile(str(generate_firmware_script)):
        raise FileNotFoundError('Failed to locate generate_firmware script')

    # locate vivado binary
    vivado_list = which('vivado')
    if not vivado_list:
        raise Exception('vivado executable not found in PATH')
    if len(vivado_list) > 2:
        logger.warning('Multiple versions of vivado: {}'.format(vivado_list))
        logger.warning('Using vivado in {}'.format(vivado_list[0]))
    else:
        logger.debug('Using vivado in {}'.format(vivado_list[0]))
    vivado_bin = vivado_list[0]

    # locate dev framework directory
    dev_framework_dir = firmware_scripts_dir.parent

    # create command string
    # framework script appears to write to stderr (to be confirmed)
    cmd = [GENERATE_FW_SCRIPT, '-p', vivado_bin, str(dev_framework_dir)]
    if dry_run:
        logger.debug('Would have run {}'.format(' '.join(cmd)))
    else:
        run(cmd, work_directory=str(firmware_scripts_dir))

    # build firmware command string
    # framework script appears to write to stderr (to be confirmed)
    cmd = [GENERATE_FW_SCRIPT, '-c', vivado_bin, str(dev_framework_dir)]
    if dry_run:
        logger.debug('Would have run {}'.format(' '.join(cmd)))
    else:
        run(cmd, work_directory=str(firmware_scripts_dir))


def main():
    """Script entry point."""
    logger.debug('sys.version_info: {}'.format(sys.version_info))
    arguments = parse_arguments()
    logger.debug('Arguments: {}'.format(arguments))
    dry_run = arguments.dry_run
    json_settings = json.load(open("./build_fpga_settings.json"))
    hls_project_dir = sys.path[0]
    firmware_project_dir = json_settings['firmwareProject']['rootDirectory']
    logger.debug('firmware_project_dir: {}'.format(firmware_project_dir))

    sha1 = get_hls_git_sha1(hls_project_dir=hls_project_dir)
    copy_rtl(hls_project_dir, firmware_project_dir, arguments)
    update_wrapper_git_value(firmware_project_dir, sha1=sha1, dry_run=dry_run)
    build_vivado_project(firmware_project_dir, dry_run=dry_run)
    pass


if __name__ == '__main__':
    """Standalone module entry point."""
    main()
